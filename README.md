# Google Developers Challenge Scholarship

##### Table of Contents  
[Stage 1](#stage1)  
[Stage 2](#stage2)  
[Stage 3](#stage3)  
[stage 4](#stage4)  
[stage 5](#stage5)  


<a name="stage1"/>

## Stage 1 [06-11-2017]

*So why not just set the minSDK to 1 and support everyone? Generally, you’ll want to target as many users as you can, but there's a cost associated with supporting older versions - things like creating different execution paths around deprecated or updated APIs, or presenting a different UX to devices with different features. You need to balance the opportunity of expanding your audience, with the cost of supporting those users.*

**Also remember that each release introduced new APIs and hardware support, so it may not make sense to make your app available to devices that don’t support your minimum feature set. Here are some examples of hardware support and features, tied to releases.**

1. Home screen widgets (Cupcake)
2. Multiple finger tracking (Froyo)
3. Tablet (Honeycomb)
4. Android Beam (Jellybean)
5. Android TV, Auto, Wear (Lollipop)
6. Pro Audio (Marshmallow)

**Setting targetSDK**
*By comparison, the targetSDK is NOT a high pass filter -- it’s used only to declare which platform version you've tested your app on. An app targeted to a certain API or Android version will continue to be forward compatible on future releases -- the platform uses the target SDK values in case a future release makes a significant change to expected behavior, ensuring your app doesn’t break when a user’s phone gets upgraded.  
Android Studio by-default targets the latest release. If you’re developing a new app, there’s really no reason to target anything but the latest Android version, and once your app has been released, make it a point to update your target SDK and test as soon as possible when new platform releases roll out, so your app can take advantage of every new platform optimization and improvement.**

>Your app runs within its own instance of the run time using the classes and services provided here in the application framework.

**The first thing that happens when you hit RUN is your code gets compiled into byte code that can be run in the run time on the device. In Android Studio is done using Gradle, a build tool kit manages dependencies and allows you to define custom build logic. For now, not that we start with your project, whic Gradle builds and then packages the byte code along with your applications resources, externalized images, UI, XML, into an Android Application Package file. An APK whic is especially formatted ZIP file. Once you got a APK ready to go Android Studio signs it through JAR Signer and then pushes it to the device using the Androdi Debug Bridge or ADB

>On Windows and Mac, the x86 emulator relies on a special kernel driver called HAXM for hardware virtualization

>A gradle task represents a single, atomic piece of work for a build. To see a list of tasks, you can open the tasks window in Android Studio by clicking on the gradle button on the far right. Clicking on the name of the task runs that task.

*Run gradle build task from the command line*
`./gradlew tasks`

*For example, to start your android app from the command line, you could type:*

`adb shell am start -n com.package.name/com.package.name.ActivityName`

**What is an Android Application**
*A collection of components that work with each other, and with the Android Framework. There are four types of components that make up apps*
1. Activity
2. Services
3. Broadcast Receiver
4. Content Providers

*Android knows about each of these components because they are registered in Android Manifest*  
*The Android Manifest is used to register components with the Android framework.*

**Activity**  
*Single focused thing that the user can do.*  
*Activities are responsible for creating the window that your application uses to draw and receive events from the system such as touch event from the system*

**Type of Views in Android**  
1. UI Components
  1. TextView
  2. EditText
  3. ImageView
  4. Button
  5. Chronometer

2. Container View
  1. LinearLayout
  2. RelativeLayout
  3. Framework
  4. ScrollView
  5. ConstraintLayout

**A word about id**
`@+id/tv_toy_names`
*The @ sign tells the tools not to treat the stuff inside the quotes as a string literal. And to instead, look for the contents inside of the Android resources. While the plus sign tells the tool to create the id if it doesn't yet exist. The id preceding the slash, lets the tools know that we're creating an id rather than a reference to something like a style, string or image drawable*

*Well the R class is autogenerated by the Android tool chain. But because Java doesn't allow for slashes in variable names the tools replace the slash after the id with a period*

#### Stage 1 Completed!

<a name="stage2"/>

## Stage 2 [7-11-2017]

**Message logging display levels**  
1. Error
2. Warn
3. INFO
4. Debug
5. Verbose
> In term of increasing verboseness in severity
>Error, Warn and Info level messages are always preserved in release versions
> During development you can also use DEBUG and VERBOSE log messages

**Android has another very special logging level that is more severe than ERROR**  
*It is called WTF for What a Terrible Failure. The WTF level is for errors that should never, ever, ever happen and most developers should never ever, ever use it. On a debug build of a device, a WTF error may force the device to halt and output a debug report. Because the behaviour of WTF isn't clearly defined, it might be best to only use the knowledge of this sepecial log level to impress your friends ;)*

>R is a static class that is generated by aapt (Android Asset Packing Tool) for us to reference resources in Java Code

*We also allow applications to specify menu items as actions. If there's enough horizontal space, those actions appear on the action bar as buttons. To do this in our menu XML, we add the show as action attribute. We're doing this in the app namespace because we're using AppCompat to make our app compatible with API Level 10 Gingerbread devices.*

**Toast**  
*Provides simple feedback about an operation in a small popup*

>use the showAsAction XML attribute. You can actually add a button to the Toolbar layout, but that's making a custom toolbar rather than making a menu item show up as a button.

*We can take advantage of the Android URI framework class. It allows us to create a well-formed URI without having to worry about the particular of URI components. For example, adding ampersands between query parameters and encoding invalid character with a percent followed by the character code*

**UTF-8**  
*Is used by JSON and JavaScript*  
**UTF-16**  
*Is the format used by android*

>While declaring a permission is required for using the camera, directly dialing the phone, and directly accessing the contact database - you can do each of these things by using a system app as an intermediator. Because the camera app, dialer, and contacts app will be used to provide the data you request - users have the chance to cancel the action you initiated, giving them runtime ability to refuse your app access.

**Your app can only access the user’s location if it explicitly declares a uses-permission.**


>NetworkOnMainThreadException only occur if your app is running in device over Gingerbread version of android if the version is Gingerbread or lower it would work fine but its a bad practice to do network stuff on Main Thread

*To run at an ideal 60 frames per second We need to make sure that all the computations between draws takes  less than 17 milliseconds*  

>After five second of ignoring user input, Android would actually prompt the user to close your app.

**AsyncTask**  
*Allows you to run a task on a background thread, while publishing results to the UI thread*  

>AsyncTask is a generic class. Meaning it takes parameterized types in its constructor. Each one of these generic parameters is to find as a Java variable argument with the three dots, which means that it is technically passed as an array in Java world.

**The three types used by an AsyncTask are the following**  
1. Params -> Parameter type sent to the task upon execution
2. Progress -> Type published to update progress dueing the background computation
3. Result -> The type of the result of the background computation

**There is a list of menthods and which runs on UI thread of background thread, got it varun!!!**  
1. execute() -> UI thread
2. onPreExecute() -> UI thread
3. doInBackground() -> Background thread
5. publishProgress() -> Background thread (called from inside the doInBackground())
6. onProgressUpdate() -> UI thread
7. onPostExecute() -> UI thread

**JSON**  
*Primary method for data exchange on the web because it's format is syntactically identical to the code for creating JavaScript objects, this means that JavaScript programs can use standard JavaScript functions to read JSON data since it's essentially native JavaScript*

**Why JSON**  
1. Human readable
2. More compact
3. Easier to write
4. Allows for declaration of arrays

#### Stage 2 Completed!

<a name="stage3"/>

## Stage 3 [08-11-2017]

*The first thing to note is that almost every part of recycler view is completely modular. The RecyclerView has an Adapter that is used to provide the RecyclerView with new views when needed. This Adapter is also used to bind data from some Data Source to the views. The adapter sends the views to a RecyclerView in an object called a ViewHolder. The ViewHolder contains a reference to the root view object for the item. And you're expected to use it to cache the view objects represented in the layout, to make it less costly to update the views with new data. This way findViewById gets called only for each data view whenever that new item is created and not each time you want to populate the views in the item with data. The LayoutManager then tells the RecyclerView how to lay out all those views. It could be a vertically scrolling list like we use in SunShine, or Horizontally scrolling lists, or even a staggered list or a grid. You get some awesome animations for item insertion and removal for free. Because it's based on a data source, it's easy for app using RecyclerView to allow for filtering a list items*  

*It's important that you use the view holder to cache the view objects that you're going to be populating with data or images. When the RecyclerView is first being populated. You call findViewById for each view that will be showing data from the adapter. This search can be expensive, especially if you have a hierarchy of views in your list item. So it's best to do it once and cache those views in a view holder. This way you can access those views later without having to look them up repeatedly. If you don't use a view holder calling findViewById for each view can get out of hand pretty quickly*  

**Let’s say that each item in your RecyclerView list contains four individual data views, and you don't cache these views in a ViewHolder. If eight items fit on screen, approximately how many extra findViewById() calls will be made if you scroll through 30 items? In addition to the eight items that fit on screen, assume that two extra items are needed for smooth scrolling.**  

**Note**:-  
*We use SP and DP when we've reffered to dimensions in Android layouts. These are both not acctual pixel sizes but are automatically scaled to be the same approximately physical size, regardless of the density of the pixels on the screen. The first Android phones were 160 dpi and i dp would actually equal to 1 pixel on these devices. The conversion of dp units to screen pixels is simple, px = dp * (dpi/160). Many modern devices have 480dpi or more. Sp work like DP but are also scaled based upon user preferences, typically the text size preference.*  

>One of the most important things a ViewHolder does is cace these references to the views that will be modified in the adapter since findViewById can get expensive

*The adapter is called by the RecyclerView to create new items in the form of ViewHolders, like the one we just created. It also populates, or binds, these items with data. And return information about the data, such as how many items there are in given data source. This data could come from an ArrayList, the JSON result of a network request, or any other data source you can model. The Adapter requires us to override three functions. The first is onCreateViewHolder, which is called when the RecyclerView instantiaes a new ViewHolder instance. The second is onBindViewHolder, which is called when RecyclerView wants to populate the view with data from our model, So that the user can see it, effectively binding it to the data source. And third is getIteCount, which returns the number of item in our data source.*  

**What is the Adapter responsible for?**  
1. Creating a ViewHolder for each RecyclerView item.  
2. Returning the numbers of items in the data source  
3. Binding data from the data source to each item.  
4. Inflating each item view that will be displayed.  

>The adapter does create ViewHolder objects and inflates item views in its onCreateViewHolder function, it also returns the number of items in the data source, and binds data from the data source to each item (even if we pass the responsibility to the ViewHolder). It doesn't cache views associated with each item (that's the job of the ViewHolder class) nor does it recycle them; that’s what our RecyclerView does.

>Whereas a ViewHolder determines how an individual entry is displayed, the LayoutManager determines how the collection of items is displayed. LayoutManager is a key part of the way recycling works in RecyclerView since it determines when to recycler items views that are no longer visible to the user.

**Note:-**  
*Assigning `setHasFixedSize(true)` to true allows RecyclerView to do some optimization on our UI, namely, allowing it to avoid invalidating the whole layout when adapter contents change*  

**Android comes with three LayoutManager**  
1. LinearLayoutManager  
2. GridLayoutManager  
3. StaggeredGridLayoutManager  

#### Stage 3 Completed!

<a name="stage4"/>

## Stage 4 [09-11-2017]

**How do we start one activity from another?**  
*Well, instead of having an activity call each other directly, Android facilitates communiction using messaging objects called Intents. Intents let an app request that an action take place. That can be anything from starting a new activity to picking or displaying a photo from your phone gallery, or make a phone call*  

>In an android application, activities can be started and stopped at any time, So the context gives us a way of doing certain things that might effect an app as a whole or might outlive the lifetime of a single activity

>Most implicit intents include two things, an action and a data. The action says what you're trying to do and the data is what you're passing onto the action

>query parameter limit from 8000 to 190,000 characters, depending on the browser used.

**A URI is like an address that points to the data you're plannning to pass through to the intended action**  

>A URI or Uniform Resource Identifier is a string of characters that identifies a resource. One of the ways you use URIs every day is when you navigate to web addresses like https://www.udacity.com The formal name of a web address is a URL or Uniform Resource Locator. A URL is a URI that identifies a web or network resource. But as we saw in the Android documentation for opening a map, a URI like geo can describe a physical location.

`scheme:[//[user:password@host[:port]][/]path[?query][#fragment]`

*Here's the full form of a URI, |^| with all the optional parts shown in brackets. It begins with a scheme. The scheme describe what type of resource we're pointing to. Popular schemes on the web are HTTP  and HTTPS, mailto, FTP, file, and geo, but there are many more. Depending on the particular scheme, it might be followed by two slashes and an authority part. The authority indicates an optional username and password to log in, a host name which could be a domain name or an IP address, and an optional port. For HTTP request, unless otherwise stated, browsers assume port 80.*

>mailto is one of the schemes that doesn't require the authority part and can worrk with just a path

>It's important to note that if there is a query paramters for our street address or business, the lat long  path must be 0,0

`geo:0,0?q=Antwerp,Belgium&z=10`

>Here is a |^| geo URI that shows the city of Antwerp in Belgium with a zoom factor of 10

*When you want to share data there's a lot more you need to think about, than if you're just starting a new activity. Depending on where you want to send the data you have to think about what type of data it is, the number of files and other things. To save you from all those concerns Android had a special helper class called ShareCompat. ShareCompat and it's inner class IntentBuilder abstract away all of these decision so you can chain together the bits that you need and ignore those that you don't*

>Every type of content that can be transmitted on the internet has two part identifier and that's called media type. You might see the more archaic name sometimes, MIME type, which stands for Multipurpose Internet Mail Extensions. When they were initially defined for RFC 2046, media types allowed you to have multi-part emails with different types of attachments. Media types are a reason why someone can send a single email with images, video and other file types as attachments, and your email client knows exactly how to interpret each file. A media type string consists of a type, a subtype, and optional paramters.*

**Media Type String**
`top-level name / subtype name [; paramters]`

**Here's an example media type that describes most of the web pages on the internet**
`text/html; charset=UTF-8`

>The type of data is text specially HTML text, and it has a character set encoding of UTF-8

**More Examples**  
1. text/plain
2. text/rtf
3. image/png
4. video/mp4

>Whenever you want ot share between apps, you'll have to specify it's media type so that Android can determine how and if it can fulfill the request

*Opening a web link would be an implicit intent because you aren’t specifying a specific browser to use, the user gets to choose.

Opening an activity uses an explicit intent because you know exactly where to go.

Sharing content to Twitter is a bit of a curveball. We’ve taught you the best way to do it using an implicit intent. It is possible as an explicit intent but not recommended.*

#### Stage 4 Completed!

<a name="stage5"/>

## Stage 5 [10-11-2017]

#### Activity Lifecycle Diagram

![Activity Lifecycle Diagram](./Activity_Lifecycle_Methods.png "Activity Lifecycle Diagram")

*The **Active** Lifecycle is when your activity is in the foreground and has focus. Here it's actively receiving input from user events. And no other activities are obscuring it. **onPause** is call, and the **active** lifetime ends as soon as your activity is partially obscured, like when you have another activity trying to fulfill an implicit intent and user needs to make a selection. So to make efficient use of limited resources, you'll want to use these signals to adjust your app's resource burden. So most updates to your UI can be paused when this life time ends, which is announced by onPause. But as you see, the app is still visible So, you shouldn't pause any processes that are drawing your UI. The visible lifetime on the other hand, continues whenever the app is all visible and ends as soon as it's completely obscured by another app. At that point our app is moved to the background. So when you see onStop you know the user can't see your app at all. So, while onCreate and onDestroy will be called at most once each time your app is run. These handler (See the picture below) are likely to be called many times while the app is running.*  

![Android App Lifecycle Methods](./Three_Activity_Lifecycle_Methods.png "Activity Lifecycle Methods")

*Rotating the device causes the Activity to be destroyed and recreated, so our lifecycle starts at onPause and ends at onResume. Note that we don't see onRestart, which only happens if the activity is stopped (but not destroyed) and then restarted.*

>OnSaveInstanceState takes a bundle as its parameter. This bundle is a key value storage mechanism that we use to store the data we want to be saved. Now it can't quite store any data. Bundles need to passed between processes or serialized to a file. So they support a limited set of types. That being said, you can add complex types to a bundle by having them implement the parcelable interface. The parcelable effectively contains the instructions for how to output an Object to a stream of data, and then recreate the object from that stream.

**onSaveInstanceState is called after the onPause but before onStop, onDestroy**

>onPause and onStop are singnals that our app may be killed imminently. So we need to clean up any resources that need an orderly tear down such as closing an open connections or sockets.

*When we destroy and recreate an activity the application continues to run. That means that all of the threads that were running continue to merrily process away. In the case of our GitHub query app it delivers the result of the query to a zombie activity that has gone away and the activity is left empty. But it's even worse in the current version of sunshine. In sunshine, we create our AsyncTask in the onCreate method of our activity. It starts a thread which begins a background task. If we rotate the device or do something else which causes the activity to be restarted, the new activity will create another async task to do the background operation. There will be extra network usage as both threads run in parallel and it will take a longer time for the user to see the result of the load. Even worse because those background thread ultimately deliver their result to a callback that's part of the activity, those async tasks actually keep all of those old zombie activities around as long as the threads are running casuing extra memory pressure. Enter loaders to solve this problem. They've been part of Android since Hineycomb and were added to the support library so they are available on any useful Android release. Loaders provide a framework to perform asynchronous loading of data. They're registered by ID, with a component called the LoaderManager, which allows them to live beyond the life cycle of the activity they are associated with, preventing duplicate loads from happening in parallel. If we want to load data on a background thread, we can use an implementation of a loader pattern called AsyncTaskLoader. The AsyncTaskLoader implements the same functionality as AsyncTask, but because its a loader its lifecycle is different. With an AsyncTaskLoader, once we rotate the device, the loader manager will make sure that the running loader is connected to the AsyncTaskLoader equivalent of onPostExecute the onLoadFinished function. The loader thread keeps running in the loadInBackground function. And once it finishes, the activity gets notified through onLoadFinished.*

>AsyncTaskLoader is a better choice for Activity-bound thread management, because it handles lifecycle changes correctly, delivering the result to the current active activity, preventing duplication of background threads, and helping to eliminate duplication of zombie activities.

*Creating loader is actually pretty simple. We start off by creating an integer constant for a loader ID. Then, we implement the loader call backs. Finally, we initialize the loader with the loaderManager*

>restartLoader will create loader if it doesn't yet exist

>Loaders are tied to the application lifecycle. They automatically handle changes in configuration, such as rotation. They are designed to reload if the user navigates away from the activity and then return. We can avoid that extra load if we don't find it desirable by caching and redelivering our existing result. 


**If you want to cache your result and put it back if you don't need to ftech the data again save the result and override deliverResult().**

#### Stage 5 Completed!
